// JavaCup specification for Mini-Pascal Compiler (mpc) parser

package MPC;

import java_cup.runtime.*;
import java.util.*;
import java.io.*;

parser code {:

  // this controls whether the parser offers extra debugging output
  public static boolean debug;

  // this indicates whether there was a parsing error
  public boolean error;

  private PrintStream errorStream;

  public Parser (MPCScanner s, PrintStream es) {
    super(s);
    errorStream = es;
  }

  public void syntax_error (Symbol currentToken) {
    Token t = (Token) currentToken.value;
    mpc.ShowError (currentToken.left, "Syntax Error: " + t.toPrettyString());
    error = true;
  }

  public static TypeId ROOT_TYPE = new TypeId(new Binding((TokenId)(TokenId.get("root")), -1, -1));

:}

// Terminals (tokens returned by the scanner).
// Note: does not include EOF, which is included automatically.

// Keywords
terminal TokenKey ABSTRACT, AND, ARRAY, BEGIN, CASE, CONST, DIV, DO, DOWNTO, ELSE, END;
terminal TokenKey FOR, FUNCTION, IF, METHODS, MOD, NIL, NOT, OBJECT, OF, OR;
terminal TokenKey OVERRIDES, PROCEDURE, PROGRAM, RECORD, REPEAT, THEN, TO, TYPE;
terminal TokenKey UNTIL, VAR, WHILE;

// Operators
terminal TokenOp LPAREN, RPAREN, COMMA, DOT, COLON, SEMI, LT, EQ, GT;
terminal TokenOp LE, NE, GE, ASSIGN;
terminal TokenOp AST, PLUS, MINUS, LBRACK, RBRACK, CARET, DOTDOT;


// Terminals with values
terminal TokenInt    INT;
terminal TokenString STRING;
terminal TokenId     ID;

// Non-terminal symbols with their Java types
non terminal Program     program;

non terminal Block       block;

non terminal Binding     binding;

non terminal List<Decl> optDefns, constDefns, varDecls, varDecl, fieldList;
non terminal List<Stmt> stmtList;
non terminal List<Binding> bindingList;
non terminal List<Expr> exprList;
non terminal List<Expr> constantList;
non terminal List<Expr> simpleTypeList;

non terminal Decl        constDefn;
non terminal Expr        expr, constant, unsignedConstant, variable;
non terminal Expr        simpleExpr, term, factor;

non terminal Type        type, simpleType;

non terminal Stmt        stmt, optElse;

non terminal Token       sign, relOp, addOp, multOp, optSemi;



// The grammar
program
    ::= PROGRAM:p binding:b SEMI block:blk DOT:dot
          {:
             Decl d = new DeclProgram(b);
             Decls dd = new Decls(d);
             RESULT = new Program(dd, blk, pleft, dotright);
           :}
     |  error {: RESULT = (Program)null; :}
     ;

block
    ::= optDefns:dd BEGIN:b stmtList:ss END:e
          {: int pos  = (dd == null) ? bleft : ddleft;
             int dEnd = (dd == null) ? bleft : ddright;
             RESULT = new Block(new Decls(dd, pos, dEnd), new Stmts(ss, bleft, eright), pos, eright);
           :}
     ;

binding
    ::= ID:n {: RESULT = new Binding(n, nleft, nright); :}
     ;

// The empty RHS rule, which occurs first in the input, creates an empty
// ArrayList of Decl nodes; other rules either tack a whole list onto it or add a
// single element. Each should be some kind of Decl node.

optDefns
    ::=
          {: RESULT = new ArrayList<Decl>(); :}
     |  optDefns:dd CONST constDefns:cc
          {: (RESULT = dd).addAll(cc); :}
     |  optDefns:dd VAR   varDecls:vv
          {: (RESULT = dd).addAll(vv); :}
     ;

// The single-item rule, which occurs first in the input, creates an empty
// ArrayList and adds the item to it. The second rule adds one item to an
// existing list.

constDefns
    ::= constDefn:d                 {: (RESULT = new ArrayList<Decl>(1)).add(d); :}
     |  constDefns:dd constDefn:d   {: (RESULT = dd).add(d); :}
     ;

constDefn
    ::= binding:b EQ constant:c SEMI
          {: RESULT = new DeclConst(b, c); :}
     |  error SEMI
          {: RESULT = null; :}
        // try to prevent errors from flowing into other declarations
     ;

// built-up somewhat like constDefns

varDecls
    ::= varDecl:d               {: RESULT = d; :}
     |  varDecls:dd varDecl:d   {: (RESULT = dd).addAll(d); :}
     ;

varDecl
    ::= bindingList:bb COLON type:t SEMI
          {: RESULT = Decl.varDeclsOf(bb, t); :}
     |  error SEMI
          {: RESULT = new ArrayList<Decl>(0); :}
     ;

bindingList
    ::= binding:b
          {: (RESULT = new ArrayList<Binding>(1)).add(b); :}
     |  bindingList:bb COMMA binding:b
          {: (RESULT = bb).add(b); :}
     ;

constant
    ::= unsignedConstant:u
          {: RESULT = u; :}
     ;

unsignedConstant
    ::= binding:b   {: RESULT = new ExprBinding(b); :}
     ;

type
    ::= simpleType:t
          {: RESULT = t; :}
     |
      	ARRAY:a LBRACK simpleTypeList:spl RBRACK OF type:e
      	{:
      		
      	   RESULT = new TypeArray(e.pos, e, aleft, eright);
      	   :}
     |
     	RECORD:r fieldList:ff END:e
     	{: 
     		:}
     |  error
          {: RESULT = Type.theErrorType; :}
     ;

fieldList
	::= 
		{:RESULT = null;:}
	 |  field:e
	    {:	ArrayList fl = new ArrayList<Decl>();
	    	fl.add(e);
	    	RESULT = fl; 
	    	:}
	 |  field:e SEMI
	    {:  ArrayList fl = new ArrayList<Decl>();
	    	fl.add(e);
	    	RESULT = fl;
	    	:}
	 |  fieldList:ee SEMI field:e
	    {: ee.add(e);
	    	RESULT = ee;
	    	:}
	 | 	fieldList:ee SEMI field:e SEMI
	 	{:	ee.add(e);
	 		RESULT = ee;
	 		:};
	    
field
	::= bindingList:bb COLON type:t 
          {: RESULT = Decl.varDeclsOf(bb, t); :};
	    
	   
simpleTypeList
	::= simpleTypeList:stl SEMI simpleType:s
		{:stl.add(s);
		  RESULT = stl;
		  :}
	 |  simpleType:s
	    {:ArrayList stl = new ArrayList<Expr>();
	      stl.add(s);
	      RESULT = stl;
	      :}

simpleType
    ::= binding:b
          {: RESULT = new TypeId(b); :}
     ;

stmt
    ::= variable:v/*call statement*/
    	  {:RESULT = new StmtCall(v);
    	    :}
     |  variable:v ASSIGN expr:e/*assign statement*/
          {: RESULT = new StmtAssign(v, e); :}
     |  BEGIN:b stmtList:ss END:e /*compound_statement*/
          {: RESULT = new StmtCompound(new Stmts(ss, bleft, eright), bleft, eright); :}
     |  IF:i expr:e THEN stmt:s1 optElse:s2 /*if statement*/
          {: int endPos = ((s2 == null) ? s1right : s2right);
             RESULT = new StmtIf(e, s1, s2, ileft, endPos);
           :}
     |  WHILE:w expr:e DO stmt:s/*while statement*/
          {: RESULT = new StmtWhile(e, s, wleft, sright); :}
     |  /*empty statement*/
          {: RESULT = new StmtEmpty(); :}
     |  CASE:c expr:e OF caseElements:ce SEMI END:ed
     	  {: :}
     |  REPEAT:r stmtList:ss UNTIL expr:e
     	  {: :}
     |  FOR:f binding:b ASSIGN expr:e1 LPAREN TO OR DOWNTO RPAREN expr:e2 DO stmt:s
     	  {: :}
     | error /*error statement*/
          {: RESULT = new StmtEmpty(); :}
     ;
     
caseElements ::= 
		caseElement:ce
		{: :}
	 |  caseElements:ces SEMI caseElement:ce
	    {: :}
	 ;
	 
caseElement ::=
		constantList:cl COLON stmt:s
		{: :};
	 
constantList ::=
		constant:c
		{::}
	 |  constantList:cl COMMA constant:c	
	 	{::}
	 	;		
     
exprList
	::= expr:e 
		  {: ArrayList<Expr> ee = new ArrayList<Expr>();
		  		ee.add(e);
		  		RESULT = ee;
		  		:}
	|  exprList:ee COMMA:c expr:e 
			{:
			ee.add(e);
			RESULT = ee;	
			:} 
	;

optElse
    ::=               {: RESULT = null; :}
     |  ELSE stmt:s   {: RESULT = s;    :}
     ;

// carefully designed to allow empty statements where
// appropriate but without ambiguity in parsing

stmtList
    ::= stmt:s                    {: (RESULT = new ArrayList<Stmt>(1)).add(s); :}
     |  stmtList:ss SEMI stmt:s   {: (RESULT = ss).add(s); :}
     ;

variable
    ::= binding:b   {: RESULT = new ExprBinding(b); :}
    |  binding:b LPAREN exprList:ee RPAREN:r
     	{: ExprCall cc = new ExprCall(false, b, new Exprs(ee, eeleft, eeright), bleft, rright);
     	     RESULT = cc; 
		:}
	|  binding:b LBRACK exprList:ee RBRACK:r
		{::}
	|  binding:b DOT binding:bb LPAREN exprList:ee RPAREN:r
		{::}
     ;
expr
    ::= simpleExpr:e
          {: RESULT = e; :}
     |  simpleExpr:e1 relOp:op simpleExpr:e2
          {: RESULT = new ExprBinary(op, e1, e2); :}
     ;

relOp
    ::= EQ   {: RESULT = TokenOp.EQ; :}
     |  NE   {: RESULT = TokenOp.NE; :}
     |  LT   {: RESULT = TokenOp.LT; :}
     |  LE   {: RESULT = TokenOp.LE; :}
     |  GE   {: RESULT = TokenOp.GE; :}
     |  GT   {: RESULT = TokenOp.GT; :}
     ;

simpleExpr
    ::= term:e
          {: RESULT = e; :}
     |  simpleExpr:e1 addOp:op term:e2
          {: RESULT = new ExprBinary(op, e1, e2); :}

     ;

addOp
    ::= OR      {: RESULT = TokenKey.OR;   :}
     ;

term
    ::= factor:e
          {: RESULT = e; :}
     |  term:e1 multOp:op factor:e2
          {: RESULT = new ExprBinary(op, e1, e2); :}
     ;

multOp
    ::= AND   {: RESULT = TokenKey.AND; :}
     ;

factor
    ::= variable:v
          {: RESULT = v; :}
     |  LPAREN expr:e RPAREN
          {: RESULT = e; :}
     |  LPAREN:l error RPAREN:r
          {: RESULT = new ExprError(lleft, rright); :}
     |  NOT:n factor:e
          {: RESULT = new ExprUnary(TokenKey.NOT, e, nleft, eright); :}
     ;
